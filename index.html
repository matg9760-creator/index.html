<!doctype html>
<html lang="fr">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>Wordle FR – Version Stable</title>
<style>
:root{
  --bg:#121213;
  --tile:#121213;
  --border:#3a3a3c;
  --text:#d7dadc;
  --green:#6aaa64;
  --yellow:#c9b458;
  --gray:#3a3a3c;
}
body{
  margin:0;
  background:var(--bg);
  color:var(--text);
  display:flex;
  justify-content:center;
  font-family:system-ui, Arial, sans-serif;
}
.app{
  width:100%;
  max-width:420px;
  padding:10px;
}
header{ text-align:center; margin:10px 0; }
h1{ letter-spacing:4px; margin:0; }

.board{ display:flex; flex-direction:column; gap:6px; align-items:center; }
.row{ display:flex; gap:6px; }
.tile{
  width:56px; height:56px;
  border:2px solid var(--border);
  background:var(--tile);
  display:flex; align-items:center; justify-content:center;
  font-size:28px; font-weight:bold;
}
.tile.active{ border-color:#5383ff; }

.keyboard{ margin-top:18px; }
.kb-row{ display:flex; justify-content:center; gap:5px; margin-bottom:6px; }
.key{
  background:#818384; color:white;
  padding:10px; border-radius:4px;
  font-weight:bold; min-width:28px; text-align:center;
  cursor:pointer; user-select:none;
}
.key.wide{ min-width:50px; }
.key.green{ background:var(--green); }
.key.yellow{ background:var(--yellow); }
.key.dark{ background:#1f1f1f; color:#777; }

/* Popup */
.modal-overlay{
  position:fixed; inset:0;
  background:rgba(0,0,0,.6);
  display:none; align-items:center; justify-content:center;
}
.modal{
  background:#1a1a1b;
  padding:20px;
  border-radius:8px;
  text-align:center;
}
.modal button{ margin-top:10px; padding:6px 12px; }

/* ===== Animations Wordle ===== */
.tile.pop{ animation: pop 120ms ease-in-out; }
@keyframes pop{ 0%{transform:scale(1)} 50%{transform:scale(1.12)} 100%{transform:scale(1)} }

.reveal{ animation: flip 600ms ease forwards; transform-style:preserve-3d; }
@keyframes flip{ 0%{transform:rotateX(0deg)} 45%{transform:rotateX(-90deg)} 55%{transform:rotateX(-90deg)} 100%{transform:rotateX(0deg)} }

.row.shake{ animation: row-shake 450ms ease; }
@keyframes row-shake{
  0%{transform:translateX(0)}
  15%{transform:translateX(-6px)}
  30%{transform:translateX(6px)}
  45%{transform:translateX(-4px)}
  60%{transform:translateX(4px)}
  75%{transform:translateX(-2px)}
  100%{transform:translateX(0)}
}

.board.win-shake{ animation: win-shake 600ms ease; }
@keyframes win-shake{
  0%{transform:translateX(0)}
  15%{transform:translateX(-6px)}
  30%{transform:translateX(6px)}
  45%{transform:translateX(-4px)}
  60%{transform:translateX(4px)}
  75%{transform:translateX(-2px)}
  100%{transform:translateX(0)}
}

.board.win-bounce{ animation: win-bounce 800ms cubic-bezier(.34,1.56,.64,1); }
@keyframes win-bounce{
  0%{transform:scale(1)}
  30%{transform:scale(1.06)}
  55%{transform:scale(0.97)}
  75%{transform:scale(1.03)}
  100%{transform:scale(1)}
}


/* ===== Animations Wordle ===== */
.tile.pop{ animation: pop 120ms ease-in-out; }
@keyframes pop{ 0%{transform:scale(1)} 50%{transform:scale(1.12)} 100%{transform:scale(1)} }

.reveal{ animation: flip 600ms ease forwards; transform-style:preserve-3d; }
@keyframes flip{ 0%{transform:rotateX(0deg)} 45%{transform:rotateX(-90deg)} 55%{transform:rotateX(-90deg)} 100%{transform:rotateX(0deg)} }

.row.shake{ animation: row-shake 450ms ease; }
@keyframes row-shake{
  0%{transform:translateX(0)}
  15%{transform:translateX(-6px)}
  30%{transform:translateX(6px)}
  45%{transform:translateX(-4px)}
  60%{transform:translateX(4px)}
  75%{transform:translateX(-2px)}
  100%{transform:translateX(0)}
}

.board.win-shake{ animation: win-shake 600ms ease; }
@keyframes win-shake{
  0%{transform:translateX(0)}
  15%{transform:translateX(-6px)}
  30%{transform:translateX(6px)}
  45%{transform:translateX(-4px)}
  60%{transform:translateX(4px)}
  75%{transform:translateX(-2px)}
  100%{transform:translateX(0)}
}

.board.win-bounce{ animation: win-bounce 800ms cubic-bezier(.34,1.56,.64,1); }
@keyframes win-bounce{
  0%{transform:scale(1)}
  30%{transform:scale(1.06)}
  55%{transform:scale(0.97)}
  75%{transform:scale(1.03)}
  100%{transform:scale(1)}
}

</style>
</head>
<body>
<div class="app">
  <header>
  <h1>WORDLE</h1>
  <div style="margin-top:8px;text-align:center;">
    <label style="font-size:12px;color:#d7dadc;">Mode :</label>
    <select id="modeSelect" style="background:#1a1a1b;color:white;border:1px solid #3a3a3c;border-radius:4px;padding:4px 6px;">
      <option value="5">5 lettres</option>
      <option value="6">6 lettres</option>
    </select>
  </div>
  <div style="margin-top:6px;text-align:center;">
    <label style="font-size:12px;color:#d7dadc;">Difficulté :</label>
    <select id="difficultySelect" style="background:#1a1a1b;color:white;border:1px solid #3a3a3c;border-radius:4px;padding:4px 6px;">
      <option value="easy">Facile</option>
      <option value="normal" selected>Normal</option>
      <option value="hard">Difficile</option>
    </select>
  </div>
</header>
  <div id="boardWrap"></div>
  <div id="keyboard" class="keyboard"></div>
</div>

<!-- Popup -->
<div class="modal-overlay" id="modal">
  <div class="modal">
    <h2 id="modalTitle"></h2>
    <p id="modalText"></p>
    <button onclick="closeModal()">Rejouer</button>
  </div>
</div>

<!-- Champ caché pour capter le clavier physique -->
<input id="kbd-capture" readonly inputmode="none" type="text" autocomplete="off" autocapitalize="off" spellcheck="false"
       style="position:fixed;opacity:0;pointer-events:none;height:0;width:0;">

<script>
document.addEventListener("DOMContentLoaded", () => {

// ===== Sounds (Wordle-like, Web Audio API) =====
const AudioCtx = window.AudioContext || window.webkitAudioContext;
const audioCtx = new AudioCtx();

function playTone(freq, duration, type='sine', volume=0.12){
  const osc = audioCtx.createOscillator();
  const gain = audioCtx.createGain();
  osc.type = type;
  osc.frequency.value = freq;
  gain.gain.value = volume;
  osc.connect(gain);
  gain.connect(audioCtx.destination);
  osc.start();
  gain.gain.exponentialRampToValueAtTime(0.001, audioCtx.currentTime + duration);
  osc.stop(audioCtx.currentTime + duration);
}

function soundTap(){ playTone(520, 0.05, 'square', 0.08); }
function soundEnter(){ playTone(420, 0.08, 'triangle', 0.12); }
function soundWin(){ playTone(660, 0.12, 'sine', 0.15); setTimeout(()=>playTone(880, 0.15, 'sine', 0.18), 140); }
function soundLose(){ playTone(220, 0.18, 'sawtooth', 0.12); }

// resume audio after first interaction
window.addEventListener('click', ()=>{
  if(audioCtx.state === 'suspended') audioCtx.resume();
}, { once:true });



const WORDS_5 = ["AMOUR","MAISON","FRUIT","ECOLE","POINT","BLANC","ROUGE","BLEU","NOIR","TABLE"];
const WORDS_6 = ["BANANE","ORANGE","VOITUR","CHALET","BOUTON","JARDIN","CAMION","SAVOIR","POULET","COUPEE"];
let solution = "";
let difficulty = 'normal';
let wordLength = 5;
let board = [];
let row = 0, col = 0, gameOver = false;

const boardWrap = document.getElementById("boardWrap");
const keyboard = document.getElementById("keyboard");
const kbd = document.getElementById("kbd-capture");

function startGame(){
  const mode = document.getElementById('modeSelect');
  wordLength = parseInt(mode.value);
  const list = wordLength === 5 ? WORDS_5 : WORDS_6;
  solution = list[Math.floor(Math.random()*list.length)];
  board = Array.from({length:6}, ()=> Array(wordLength).fill(""));
  row = 0; col = 0; gameOver = false;
  renderBoard();
  renderKeyboard();
  selectTile(0,0);
}

const modeSelect = document.getElementById('modeSelect');
const difficultySelect = document.getElementById('difficultySelect');
modeSelect.addEventListener('change', startGame);
difficultySelect.addEventListener('change', ()=>{
  difficulty = difficultySelect.value;
});


function renderBoard(){
  boardWrap.innerHTML = "";
  const b = document.createElement("div"); b.className = "board";
  for(let r=0;r<6;r++){
    const line = document.createElement("div"); line.className = "row";
    for(let c=0;c<wordLength;c++){
      const t = document.createElement("div");
      t.className = "tile";
      t.id = `tile-${r}-${c}`;
      t.onclick = () => selectTile(r,c);
      line.appendChild(t);
    }
    b.appendChild(line);
  }
  boardWrap.appendChild(b);
}

const KB = ["AZERTYUIOP","QSDFGHJKLM","WXCVBN"];
function renderKeyboard(){
  keyboard.innerHTML = "";
  KB.forEach(r=>{
    const rowDiv = document.createElement("div"); rowDiv.className = "kb-row";
    [...r].forEach(ch=>{
      const k = document.createElement("div"); k.className = "key"; k.textContent = ch;
      k.onclick = () => handleKey(ch);
      rowDiv.appendChild(k);
    });
    keyboard.appendChild(rowDiv);
  });
  const act = document.createElement("div"); act.className = "kb-row";
  const enter = document.createElement("div"); enter.className = "key wide"; enter.textContent = "Entrer"; enter.onclick = onEnter;
  const back = document.createElement("div"); back.className = "key wide"; back.textContent = "Suppr"; back.onclick = onBack;
  act.appendChild(enter); act.appendChild(back);
  keyboard.appendChild(act);
}

function handleKey(letter){
  soundTap();
  const tileEl = document.getElementById(`tile-${row}-${col}`);
  if(tileEl){ tileEl.classList.remove('pop'); void tileEl.offsetWidth; tileEl.classList.add('pop'); }

  soundTap();
  if(gameOver) return;
  if(col < wordLength){
    board[row][col] = letter;
    document.getElementById(`tile-${row}-${col}`).textContent = letter;
    if(col < wordLength-1) selectTile(row, col+1);
  }
}

function onBack(){
  soundTap();
  if(gameOver) return;
  if(col > 0) col--;
  board[row][col] = "";
  document.getElementById(`tile-${row}-${col}`).textContent = "";
  selectTile(row,col);
}

function onEnter(){
  soundEnter();
  const rowEl = document.querySelectorAll('.row')[row];
  if(gameOver) return;

  // Vérification mode difficile (Hard mode)
  if(difficulty === 'hard' && row > 0){
    const prevRow = board[row-1];
    const currentGuess = board[row];

    // Lettres vertes doivent rester à la même position
    for(let i=0;i<wordLength;i++){
      const prevTile = document.getElementById(`tile-${row-1}-${i}`);
      if(prevTile.style.background === 'var(--green)'){
        if(currentGuess[i] !== prevRow[i]){
          if(rowEl){ rowEl.classList.remove('shake'); void rowEl.offsetWidth; rowEl.classList.add('shake'); }
          return;
        }
      }
    }

    // Lettres jaunes doivent être réutilisées
    for(let i=0;i<wordLength;i++){
      const prevTile = document.getElementById(`tile-${row-1}-${i}`);
      if(prevTile.style.background === 'var(--yellow)'){
        if(!currentGuess.includes(prevRow[i])){
          if(rowEl){ rowEl.classList.remove('shake'); void rowEl.offsetWidth; rowEl.classList.add('shake'); }
          return;
        }
      }
    }
  }

  if(board[row].includes("")){
    if(rowEl){ rowEl.classList.remove('shake'); void rowEl.offsetWidth; rowEl.classList.add('shake'); }
    return;
  }

  revealRow();

  if(board[row].join("") === solution){
    const boardEl = document.querySelector('.board');
    if(boardEl){
      boardEl.classList.add('win-shake');
      setTimeout(()=>{
        boardEl.classList.remove('win-shake');
        boardEl.classList.add('win-bounce');
        setTimeout(()=>boardEl.classList.remove('win-bounce'),900);
      },650);
    }
    soundWin();
    showModal("Bravo !", "Mot trouvé : " + solution);
    gameOver = true; return;
  }

  row++; col = 0;
  if(row >= 6){
    soundLose();
    showModal("Perdu", "Mot : " + solution);
    gameOver = true; return;
  }
  selectTile(row,0);
}


function revealRow(){
  const rowEl = document.querySelectorAll('.row')[row];
  const guess = board[row].join("");
  const sol = [...solution];
  const res = Array(wordLength).fill("gray");

  for(let i=0;i<wordLength;i++){
    if(guess[i] === sol[i]){ res[i] = "green"; sol[i] = null; }
  }
  for(let i=0;i<wordLength;i++){
    if(res[i] === "gray"){
      const idx = sol.indexOf(guess[i]);
      if(idx !== -1){ res[i] = "yellow"; sol[idx] = null; }
    }
  }

  for(let i=0;i<wordLength;i++){
    const t = document.getElementById(`tile-${row}-${i}`);
    t.classList.remove('reveal'); void t.offsetWidth; t.classList.add('reveal');
    if(res[i] === "green") t.style.background = "var(--green)";
    else if(res[i] === "yellow") t.style.background = "var(--yellow)";
    else t.style.background = "var(--gray)";
  }
  updateKeyboard(guess, res);
}

function updateKeyboard(guess, res){
  for(let i=0;i<wordLength;i++){
    const letter = guess[i];
    const keys = [...document.querySelectorAll('.key')].filter(k=>k.textContent === letter);
    keys.forEach(k=>{
      if(res[i] === "green") k.className = "key green";
      else if(res[i] === "yellow" && !k.classList.contains("green")) k.className = "key yellow";
      else if(res[i] === "gray") k.className = "key dark";
    });
  }
}

function selectTile(r,c){
  document.querySelectorAll('.tile').forEach(t=>t.classList.remove('active'));
  row = r; col = c;
  const t = document.getElementById(`tile-${r}-${c}`);
  if(t) t.classList.add('active');
}

// Popup
function showModal(title,text){
  document.getElementById("modalTitle").textContent = title;
  document.getElementById("modalText").textContent = text;
  document.getElementById("modal").style.display = "flex";
}
window.closeModal = function(){
  document.getElementById("modal").style.display = "none";
  startGame();
}

// ===== Clavier physique (PC) sans ouvrir le clavier mobile =====
// On utilise directement window.keydown pour PC.
// Sur mobile, Safari ignore naturellement cet événement sans afficher le clavier.

const accentMap = {
  'é':'E','è':'E','ê':'E','ë':'E',
  'à':'A','â':'A','ä':'A',
  'î':'I','ï':'I',
  'ô':'O','ö':'O',
  'ù':'U','û':'U','ü':'U',
  'ç':'C'
};

window.addEventListener('keydown', (e) => {
  if(gameOver) return;

  // Empêcher le scroll avec espace ou flèches
  if(['ArrowUp','ArrowDown','ArrowLeft','ArrowRight',' '].includes(e.key)){
    e.preventDefault();
  }

  if(e.key === 'Enter'){ e.preventDefault(); onEnter(); return; }
  if(e.key === 'Backspace'){ e.preventDefault(); onBack(); return; }

  let key = e.key;
  if(accentMap[key]) key = accentMap[key];
  else key = key.toUpperCase();

  if(/^[A-Z]$/.test(key)){
    e.preventDefault();
    handleKey(key);
  }
});

// Reprendre le focus clavier au clic
// Reprendre le focus clavier UNIQUEMENT quand on clique sur le clavier virtuel (évite l'ouverture auto du clavier mobile)
document.body.addEventListener('click', (e)=>{
  // Si on clique dans le clavier virtuel, on autorise le focus pour le clavier physique
  const keyboardArea = document.getElementById('keyboard');
  if(keyboardArea && keyboardArea.contains(e.target)){
    kbd.focus();
  }
});

// Démarrage du jeu
startGame();

// Sur mobile/iPad : ne jamais donner le focus automatique à l’input caché
// Le focus ne sera donné que si l’utilisateur clique sur le clavier virtuel

});
</script>
</body>
</html>
